# =============================================================================
# Docker Compose — Développement avec Hot Reload
# =============================================================================
#
# Ce fichier orchestre tous les services en mode DÉVELOPPEMENT.
# Contrairement à une config de production :
#   - Le code source est monté en volume (bind mount) → les modifications
#     sur ta machine sont instantanément visibles dans les conteneurs
#   - Les backends utilisent tsx watch → redémarrage auto à chaque changement
#   - Les frontends utilisent vite dev → HMR (Hot Module Replacement)
#   - Toutes les dépendances (y compris devDeps) sont installées
#
# Commandes utiles :
#   docker compose up              → construit et lance tous les services
#   docker compose up -d           → idem, en arrière-plan (detached)
#   docker compose up --build      → force la reconstruction des images
#   docker compose down            → arrête et supprime les conteneurs
#   docker compose down -v         → idem + supprime les volumes (données BDD)
#   docker compose logs -f         → affiche les logs en temps réel
#   docker compose logs -f <nom>   → logs d'un seul service (ex: writer-api)
#   docker compose ps              → liste les conteneurs en cours
#
# =============================================================================
# CONCEPTS CLÉS UTILISÉS DANS CE FICHIER
# =============================================================================
#
# image vs build :
#   "image:" télécharge une image existante (ex: postgres officiel).
#   "build:" construit une image depuis un Dockerfile local.
#
# ports (HOST:CONTENEUR) :
#   Le conteneur a son propre réseau isolé. "ports" crée un tunnel entre
#   un port de ta machine (hôte) et un port du conteneur.
#   Ex: "5173:5173" → localhost:5173 sur ton navigateur arrive au port 5173
#   du conteneur où Vite dev server écoute.
#
# volumes (bind mount) :
#   Un bind mount partage un dossier de ta machine avec le conteneur.
#   Syntaxe : ./chemin/local:/chemin/conteneur
#   → Tout changement d'un côté est visible de l'autre en temps réel.
#   C'est ce qui permet le hot reload sans reconstruire l'image.
#
#   PIÈGE DES NODE_MODULES :
#   Quand on monte ./writer/backend:/app, le dossier node_modules de
#   ta machine écrase celui installé dans l'image Docker (qui peut être
#   différent, ex: binaires compilés pour Linux vs macOS).
#   Pour éviter ça, on utilise un "volume anonyme" sur node_modules :
#     - /app/node_modules
#   Ce volume dit à Docker : "pour CE dossier, garde la version du conteneur
#   et ignore celle de l'hôte". Ainsi npm ci dans le Dockerfile est préservé.
#
# depends_on + healthcheck :
#   Définit l'ordre de démarrage. Avec "condition: service_healthy",
#   le service attend que le healthcheck de sa dépendance soit au vert.
#   Sans ça, l'API pourrait démarrer avant que PostgreSQL soit prêt → crash.
#
# environment :
#   Injecte des variables d'environnement au runtime dans le conteneur.
#   ${VARIABLE} est lue depuis le fichier .env à la racine du projet.
#
# restart: unless-stopped :
#   Redémarre le conteneur automatiquement en cas de crash,
#   sauf si on l'a arrêté manuellement avec docker compose down.
#

# =============================================================================
# SERVICES — Chaque bloc décrit un conteneur indépendant
# =============================================================================
#   db              → PostgreSQL (base de données partagée)
#   writer-api      → Backend Writer (Express + TypeORM, tsx watch)
#   reader-api      → Backend Reader (Express + Prisma, tsx watch)
#   writer-front    → Frontend Writer (React, Vite dev server + HMR)
#   reader-front    → Frontend Reader (React, Vite dev server + HMR)
services:

  # ===========================================================================
  # BASE DE DONNÉES — PostgreSQL
  # ===========================================================================
  # Pas besoin de Dockerfile : l'image officielle est prête à l'emploi.
  # Elle fournit un mécanisme d'initialisation automatique :
  # tout fichier .sql placé dans /docker-entrypoint-initdb.d/ est exécuté
  # au tout premier démarrage (base vierge), dans l'ordre alphabétique.
  db:
    image: postgres:17-alpine
    restart: unless-stopped
    environment:
      # Variables lues par l'image officielle PostgreSQL.
      # POSTGRES_DB crée automatiquement la base au démarrage.
      POSTGRES_DB: ${POSTGRES_DB}
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
    ports:
      # Accessible sur localhost:5432 (utile pour se connecter via pgAdmin/DBeaver)
      - "5432:5432"
    volumes:
      # Scripts SQL d'initialisation, exécutés une seule fois dans cet ordre :
      #   01-schema.sql     → schémas, tables, vues matérialisées, triggers
      #   02-categories.sql → catégories
      #   03-seed.sql       → articles de test
      # ":ro" = read-only, empêche le conteneur de modifier ces fichiers.
      - ./db:/docker-entrypoint-initdb.d:ro
      # Volume nommé pour persister les données entre les redémarrages.
      # Sans ça, un "docker compose down" effacerait toute la base.
      - pgdata:/var/lib/postgresql/data
    # Vérifie toutes les 5s que PostgreSQL accepte les connexions.
    # Les backends utilisent ce healthcheck via depends_on → condition.
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
      interval: 5s
      timeout: 5s
      retries: 5

  # ===========================================================================
  # BACKEND WRITER — Express + TypeORM (tsx watch)
  # ===========================================================================
  writer-api:
    build:
      context: ./writer/backend
    restart: unless-stopped
    environment:
      PORT: 3000
      NODE_ENV: development
      FRONTEND_URL: http://localhost:5173
      # DB_HOST vaut "db" et non "localhost" : dans le réseau Docker,
      # les conteneurs se trouvent entre eux par leur nom de service.
      DB_HOST: db
      DB_PORT: 5432
      DB_NAME: ${POSTGRES_DB}
      DB_USER: ${POSTGRES_USER}
      DB_PASSWORD: ${POSTGRES_PASSWORD}
      GEMINI_API_KEY: ${GEMINI_API_KEY}
    ports:
      - "3000:3000"
    volumes:
      # Bind mount : le code source de ta machine est partagé avec le conteneur.
      # Quand tu modifies un fichier dans writer/backend/src/, tsx watch détecte
      # le changement et redémarre automatiquement le serveur dans le conteneur.
      - ./writer/backend/src:/app/src
      # On monte aussi le tsconfig.json pour que tsx respecte la config
      # TypeScript (notamment experimentalDecorators requis par TypeORM).
      - ./writer/backend/tsconfig.json:/app/tsconfig.json
      # Volume anonyme : protège le node_modules du conteneur.
      # Sans ça, le mount du dossier parent écraserait les node_modules
      # installés par npm ci dans le Dockerfile (qui sont compilés pour Linux).
      - /app/node_modules
    depends_on:
      db:
        condition: service_healthy

  # ===========================================================================
  # BACKEND READER — Express + Prisma (tsx watch)
  # ===========================================================================
  reader-api:
    build:
      context: ./reader/backend
    restart: unless-stopped
    environment:
      PORT: 3001
      FRONTEND_URL: http://localhost:5174
      # Prisma attend une URL de connexion complète (format standard PostgreSQL).
      DATABASE_URL: postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@db:5432/${POSTGRES_DB}
    ports:
      - "3001:3001"
    volumes:
      # Bind mount du code source pour le hot reload via tsx watch.
      - ./reader/backend/src:/app/src
      - ./reader/backend/tsconfig.json:/app/tsconfig.json
      # Volume anonyme pour protéger les node_modules du conteneur.
      - /app/node_modules
    depends_on:
      db:
        condition: service_healthy

  # ===========================================================================
  # FRONTEND WRITER — React (Vite dev server + HMR)
  # ===========================================================================
  writer-front:
    build:
      context: ./writer/frontend
    restart: unless-stopped
    environment:
      # En dev, VITE_* peut être lu via process.env car le serveur Vite
      # les injecte dynamiquement (contrairement au build de prod où les
      # valeurs sont écrites en dur dans le JS compilé via "args:").
      VITE_API_URL: http://localhost:3000/api
    ports:
      # Vite dev server écoute sur 5173 dans le conteneur.
      - "5173:5173"
    volumes:
      # Bind mount du code source pour le HMR.
      # Quand tu modifies un composant React, Vite envoie la mise à jour
      # au navigateur via WebSocket → le composant est remplacé à chaud
      # sans recharger la page entière.
      - ./writer/frontend/src:/app/src
      - ./writer/frontend/index.html:/app/index.html
      # On monte aussi les fichiers de config pour que les changements
      # de config Vite/TypeScript soient pris en compte sans rebuild.
      - ./writer/frontend/vite.config.ts:/app/vite.config.ts
      - ./writer/frontend/tsconfig.json:/app/tsconfig.json
      - ./writer/frontend/tsconfig.app.json:/app/tsconfig.app.json
      - ./writer/frontend/tsconfig.node.json:/app/tsconfig.node.json
      # Volume anonyme pour protéger les node_modules du conteneur.
      - /app/node_modules
    depends_on:
      - writer-api

  # ===========================================================================
  # FRONTEND READER — React (Vite dev server + HMR)
  # ===========================================================================
  reader-front:
    build:
      context: ./reader/frontend
    restart: unless-stopped
    environment:
      VITE_API_URL: http://localhost:3001
    ports:
      # Port 5174 pour ne pas entrer en conflit avec le Writer (5173).
      - "5174:5174"
    volumes:
      # Bind mount du code source pour le HMR.
      - ./reader/frontend/src:/app/src
      - ./reader/frontend/index.html:/app/index.html
      - ./reader/frontend/vite.config.ts:/app/vite.config.ts
      - ./reader/frontend/tsconfig.json:/app/tsconfig.json
      - ./reader/frontend/tsconfig.app.json:/app/tsconfig.app.json
      - ./reader/frontend/tsconfig.node.json:/app/tsconfig.node.json
      # Volume anonyme pour protéger les node_modules du conteneur.
      - /app/node_modules
    depends_on:
      - reader-api

# =============================================================================
# VOLUMES
# =============================================================================
# Déclare les volumes nommés utilisés par les services.
# Les données de PostgreSQL sont stockées sur le disque de la machine hôte,
# en dehors du cycle de vie des conteneurs.
# Pour réinitialiser la base : docker compose down -v
volumes:
  pgdata:
